<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <title>Introduction - Learn You a Haskell for Great Good!</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <base href="http://learnyouahaskell.com/">
    <style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style>
    <link rel="shortcut icon" href="favicon.png" type="image/png">
    <link rel="next" href="starting-out">
    <link type="text/css" rel="stylesheet"
      href="sh/Styles/SyntaxHighlighter.css">
    <link href="rss.php" rel="alternate" type="application/rss+xml"
      title="Learn You a Haskell for Great Good! feed">
  </head>
  <body class="introcontent">
    <div class="bgwrapper">
      <div id="content">
        <div class="footdiv" style="margin-bottom:25px;">
          <ul>
            <li style="text-align:left"> <br>
            </li>
            <li style="text-align:center"> <a href="chapters">Table of
                contents</a> </li>
            <li style="text-align:right"> <a href="starting-out"
                class="nxtlink">Starting Out</a> </li>
          </ul>
        </div>
        <h1>Giriş</h1>
        <a name="about-this-tutorial"></a>
        <h2>Bu bilgilendirici hakkında<br>
        </h2>
        <p><em>Learn You a Haskell for Great Good</em>'a hoş geldiniz!
          Eğer bunu okuyorsanız, muhtemelen Haskell öğrenmek
          istiyorsunuz. O zaman doğru yere geldiniz, tabi önce bu
          bilgilendirici hakkında biraz konuşalım. </p>
        <p>
          Kendi bilgilerimi somutlaştırmak ve Haskell öğrenmeye&nbsp;
          yeni başlamış insanlara, kendi bakış açımdan yardım edebilecği
          i düşündüğüm için bunu yazmaya karar verdim. İnternette
          dolaşan bir çok Haskell bilgilendiricisi bulunuyor.&nbsp;
          Haskell'e başladığımda tek bir kaynağa bağımlı kalmadım. Her
          biri diğerinden farklı bir yolla anlattığı için bir çok farklı
          bilgilendirici ve makaleyi okuyarak öğrendim. <font
            color="#ff0000">Bir çok kaynaktan faydalanarak parçaları
            birleştirdim ve ortaya çıkardım.</font><font color="#9999ff">
          </font>Bu yüzden bu başka bir faydalı Haskell kaynağı ortaya
          çıkarma çabasıdır. Hoşunuza gidecek birini bulma olasığınız
          yükselmiş oldu.<font color="#9999ff">
          </font></p>
        <font color="#9999ff">
          <img src="http://s3.amazonaws.com/lyah/bird.png" alt="bird"
            class="left" height="192" width="230">
        </font>
        <p>Bu bilgilendirici <a
            href="https://en.wikipedia.org/wiki/Imperative_programming">imperative
            programlama</a>(C, C++, Java, Python ...) üzerine çalışmış
          ancak daha önce <a
            href="https://en.wikipedia.org/wiki/Functional_programming">fonksiyonel
            programlama</a>(Haskell, ML, OCaml ...) ile ilgilenmemiş
          geliştiricileri hedef almıştır. Buna rağmen iddiaya girerim
          sizin gibi zeki bir insan, kayda değer programlama deneyimi
          olmadan dahi takip edebilir ve Haskell'i öğrenebilir.<font
            color="#9999ff">
          </font></p>
        <font color="#9999ff">
        </font>
        <p>Freenode ağındaki #haskell kanalı takıldığınızı
          hissettiğinizde soru sormak için gayet uygun bir yer. Orada
          gayet hoş sabırlı ve yeni başlayanlara anlayışlı insanlar var.<font
            color="#9999ff">
          </font></p>
        <font color="#9999ff">
        </font>
        <p><font color="#9999ff">
          </font>Tam olarak kavrayana kadar sırf garip geldiği için iki
          defa Haskell öğrenmeyi denedim ve başaramadım. Ama sonra ilk
          engeli aştıktan sonra gerisi çorap söküğü gibi geldi. Kısaca
          söylemek istediğim, Haskell gayet güzel ve eğer programlama
          ile ilgileniyorsanız ilk başta biraz garip görünse de
          kesinlikle öğrenmelisiniz. Haskell öğrenmek daha çok ilk defa
          programlama öğrenmek gibi - eğlenceli! Sizi farklı düşünmeye
          zorluyor ki <font color="#ff0000">şimdi karşınızda sıradaki
            adım.</font><font color="#9999ff"><br>
          </font></p>
        <font color="#9999ff">
          <a name="so-whats-haskell"></a></font>
        <h2>Nedir bu Haskell?<font color="#9999ff"><br>
          </font></h2>
        <font color="#9999ff">
        </font>
        <p>
          <font color="#9999ff"><img
              src="http://s3.amazonaws.com/lyah/fx.png" alt="fx"
              class="right" height="146" width="150">
          </font>Haskell, tamamen fonksiyonel bir programlama dilidir. <font
            color="#ff0000"><a
              href="https://en.wikipedia.org/wiki/Imperative_programming">Imperative
              diller</a>de bilgisayara bir dizi görev verir ve bunları
            sıra ile gerçekleştirmesi sonuncu amacınıza ulaşırsınız</font>.
          Görevleri yerine getirirken bellekte durum değişikliklerine
          sebep olabilir. Örneğin <span class="fixed">a</span>
          değişkenine 5 değerini atadınız sonra başka bir şeyler
          yaptınız ve değişkene başka bir değer atadınız. <font
            color="#ff0000">Bazı şeyleri defalarca tekrarlamak için akış
            kontrol yapılarınız var</font>. Fonksiyonel programlamada
          bilgisayara neyi nasıl yapacağını değil neyin ne olduğunu
          söylersiniz. Bir sayının faktöriyelinin hesaplanması, 1'den o
          sayıya kadar olan tüm sayıların birbirleri ile çarpımı ile
          liste içindeki sayıların toplamı ise ilk eleman ile ikinci
          elemanın&nbsp; toplamı ile üçüncünün toplamı ve sonucu ya
          kadar tekrar edilerek&nbsp; elde edilir. Bunları fonksiyonlar
          şeklinde ifade edebilirsiniz. Ayrıca bir değişkene bir değeri
          atayıp daha sonra başka bir şeyi atayamazsınız. Eğer <span
            class="fixed">a</span> ya 5 dediyseniz, sonra başka bir
          değer atayamazsınız çünkü zaten onun değerini bir sefer atamış
          olursunuz.<font color="#9999ff">&nbsp; If you say that <span
              class="fixed">a</span> is 5, you can't say it's something
            else later because you just said it was 5. What are you,
            some kind of liar? So in purely functional languages, a
            function has no side-effects. The only thing a function can
            do is calculate something and return it as a result. At
            first, this seems kind of limiting but it actually has some
            very nice consequences: if a function is called twice with
            the same parameters, it's guaranteed to return the same
            result. That's called referential transparency and not only
            does it allow the compiler to reason about the program's
            behavior, but it also allows you to easily deduce (and even
            prove) that a function is correct and then build more
            complex functions by gluing simple functions together.
          </font></p>
        <font color="#9999ff">
        </font>
        <p>
          <font color="#9999ff"><img
              src="http://s3.amazonaws.com/lyah/lazy.png" class="right"
              alt="lazy" height="209" width="240">
            Haskell is <em>lazy</em>. That means that unless
            specifically told otherwise, Haskell won't execute functions
            and calculate things until it's really forced to show you a
            result. That goes well with referential transparency and it
            allows you to think of programs as a series of <em>transformations
              on data</em>. It also allows cool things such as infinite
            data structures. Say you have an immutable list of numbers <span
              class="fixed">xs = [1,2,3,4,5,6,7,8]</span> and a function
            <span class="fixed">doubleMe</span> which multiplies every
            element by 2 and then returns a new list. If we wanted to
            multiply our list by 8 in an imperative language and did <span
              class="fixed">doubleMe(doubleMe(doubleMe(xs)))</span>, it
            would probably pass through the list once and make a copy
            and then return it. Then it would pass through the list
            another two times and return the result. In a lazy language,
            calling <span class="fixed">doubleMe</span> on a list
            without forcing it to show you the result ends up in the
            program sort of telling you "Yeah yeah, I'll do it later!".
            But once you want to see the result, the first <span
              class="fixed">doubleMe</span> tells the second one it
            wants the result, now! The second one says that to the third
            one and the third one reluctantly gives back a doubled 1,
            which is a 2. The second one receives that and gives back 4
            to the first one. The first one sees that and tells you the
            first element is 8. So it only does one pass through the
            list and only when you really need it. That way when you
            want something from a lazy language you can just take some
            initial data and efficiently transform and mend it so it
            resembles what you want at the end.
          </font></p>
        <font color="#9999ff">
        </font>
        <p>
          <font color="#9999ff"><img
              src="http://s3.amazonaws.com/lyah/boat.png" class="right"
              alt="boat" height="153" width="160">
            Haskell is <em>statically typed</em>. When you compile your
            program, the compiler knows which piece of code is a number,
            which is a string and so on. That means that a lot of
            possible errors are caught at compile time. If you try to
            add together a number and a string, the compiler will whine
            at you. Haskell uses a very good type system that has <em>type
              inference</em>. That means that you don't have to
            explicitly label every piece of code with a type because the
            type system can intelligently figure out a lot about it. If
            you say <span class="fixed">a = 5 + 4</span>, you don't
            have to tell Haskell that <span class="fixed">a</span> is a
            number, it can figure that out by itself. Type inference
            also allows your code to be more general. If a function you
            make takes two parameters and adds them together and you
            don't explicitly state their type, the function will work on
            any two parameters that act like numbers.
          </font></p>
        <font color="#9999ff">
        </font>
        <p><font color="#9999ff">
            Haskell is <em>elegant and concise</em>. Because it uses a
            lot of high level concepts, Haskell programs are usually
            shorter than their imperative equivalents. And shorter
            programs are easier to maintain than longer ones and have
            less bugs.
          </font></p>
        <font color="#9999ff">
        </font>
        <p><font color="#9999ff"> Haskell was made by some <em>really
              smart guys</em> (with PhDs). Work on Haskell began in 1987
            when a committee of researchers got together to design a
            kick-ass language. In 2003 the Haskell Report was published,
            which defines a stable version of the language.
          </font></p>
        <font color="#9999ff">
          <a name="what-you-need"></a></font>
        <h2><font color="#9999ff">What you need to dive in</font></h2>
        <font color="#9999ff">
        </font>
        <p><font color="#9999ff">
            A text editor and a Haskell compiler. You probably already
            have your favorite text editor installed so we won't waste
            time on that. For the purposes of this tutorial we'll be
            using GHC, the most widely used Haskell compiler. The best
            way to get started is to download the <a
              href="http://hackage.haskell.org/platform/">Haskell
              Platform</a>, which is basically Haskell with batteries
            included.
          </font></p>
        <font color="#9999ff">
        </font>
        <p><font color="#9999ff">
            GHC can take a Haskell script (they usually have a .hs
            extension) and compile it but it also has an interactive
            mode which allows you to interactively interact with
            scripts. Interactively. You can call functions from scripts
            that you load and the results are displayed immediately. For
            learning it's a lot easier and faster than compiling every
            time you make a change and then running the program from the
            prompt. The interactive mode is invoked by typing in <span
              class="fixed">ghci</span> at your prompt. If you have
            defined some functions in a file called, say, <span
              class="fixed">myfunctions.hs</span>, you load up those
            functions by typing in <span class="fixed">:l myfunctions</span>
            and then you can play with them, provided <span
              class="fixed">myfunctions.hs</span> is in the same folder
            from which <span class="fixed">ghci</span> was invoked. If
            you change the .hs script, just run <span class="fixed">:l
              myfunctions</span> again or do <span class="fixed">:r</span>,
            which is equivalent because it reloads the current script.
            The usual workflow for me when playing around in stuff is
            defining some functions in a .hs file, loading it up and
            messing around with them and then changing the .hs file,
            loading it up again and so on. This is also what we'll be
            doing here.
          </font></p>
        <div class="footdiv">
          <ul>
            <li style="text-align:left"> <br>
            </li>
            <li style="text-align:center"> <a href="chapters">Table of
                contents</a> </li>
            <li style="text-align:right"> <a href="starting-out"
                class="nxtlink">Starting Out</a> </li>
          </ul>
        </div>
      </div>
      <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
      <script type="text/javascript" src="shBrushHaskell.js"></script>
      <script type="text/javascript" src="shBrushPlain.js"></script>
      <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script>
    </div>
    <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
    <script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script>
  </body>
</html>
